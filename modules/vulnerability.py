
"""
Vulnerability Scanner Module for PhantomUF
Scans for system vulnerabilities and security misconfigurations
"""

import os
import re
import json
import socket
import logging
import threading
import subprocess
from datetime import datetime
from collections import defaultdict

logger = logging.getLogger("PhantomUF.Vulnerability")

class VulnerabilityScanner:
    """Scans for system vulnerabilities and security misconfigurations"""
    
    def __init__(self, config, log_manager):
        self.config = config
        self.log_manager = log_manager
        self.running = False
        self.scan_results = {}
        self.vulnerability_database = self._load_vulnerability_database()
        self.scheduled_scans = []
        
    def initialize(self):
        """Initialize the vulnerability scanner component"""
        logger.info("Initializing Vulnerability Scanner...")
        
        # Load scan schedules from config
        scan_schedule = self.config.get("vulnerability_scan_schedule", {})
        for scan_type, schedule in scan_schedule.items():
            self.scheduled_scans.append({
                'type': scan_type,
                'schedule': schedule,
                'last_run': None
            })
            
    def start(self):
        """Start the vulnerability scanner service"""
        if self.running:
            logger.warning("Vulnerability Scanner is already running")
            return
            
        logger.info("Starting Vulnerability Scanner...")
        self.running = True
        
        # Start scheduler thread
        threading.Thread(target=self._scheduler, daemon=True).start()
        
        logger.info("Vulnerability Scanner started successfully")
        
    def stop(self):
        """Stop the vulnerability scanner service"""
        if not self.running:
            logger.warning("Vulnerability Scanner is not running")
            return
            
        logger.info("Stopping Vulnerability Scanner...")
        self.running = False
        logger.info("Vulnerability Scanner stopped successfully")
        
    def run_scan(self, scan_type="full"):
        """Run a vulnerability scan"""
        logger.info(f"Starting {scan_type} vulnerability scan")
        self.log_manager.log_event(
            "vulnerability",
            f"Starting {scan_type} vulnerability scan",
            "INFO"
        )
        
        scan_results = {
            'scan_id': f"scan_{datetime.now().strftime('%Y%m%d%H%M%S')}",
            'scan_type': scan_type,
            'start_time': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'end_time': None,
            'findings': [],
            'summary': {
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            }
        }
        
        try:
            # Run different scans based on type
            if scan_type == "full" or scan_type == "system":
                self._scan_system_vulnerabilities(scan_results)
                
            if scan_type == "full" or scan_type == "network":
                self._scan_network_vulnerabilities(scan_results)
                
            if scan_type == "full" or scan_type == "web":
                self._scan_web_vulnerabilities(scan_results)
                
            if scan_type == "full" or scan_type == "config":
                self._scan_config_vulnerabilities(scan_results)
                
            # Mark scan as complete
            scan_results['end_time'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # Save scan results
            self.scan_results[scan_results['scan_id']] = scan_results
            
            # Log summary
            summary = scan_results['summary']
            total_findings = sum(summary.values())
            
            self.log_manager.log_event(
                "vulnerability",
                f"Vulnerability scan completed: {total_findings} findings "
                f"(High: {summary['high']}, Medium: {summary['medium']}, "
                f"Low: {summary['low']}, Info: {summary['info']})",
                "WARNING" if summary['high'] > 0 else "INFO"
            )
            
            # Return the scan ID
            return scan_results['scan_id']
            
        except Exception as e:
            logger.error(f"Error during vulnerability scan: {e}")
            
            scan_results['end_time'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            scan_results['error'] = str(e)
            
            self.log_manager.log_event(
                "vulnerability",
                f"Vulnerability scan failed: {e}",
                "ERROR"
            )
            
            return None
            
    def get_scan_results(self, scan_id=None):
        """Get vulnerability scan results"""
        if scan_id:
            return self.scan_results.get(scan_id)
        else:
            # Return the most recent scan
            if not self.scan_results:
                return None
            latest_id = sorted(self.scan_results.keys())[-1]
            return self.scan_results[latest_id]
            
    def get_remediation_recommendations(self, finding_id):
        """Get remediation recommendations for a vulnerability finding"""
        for scan_id, scan_data in self.scan_results.items():
            for finding in scan_data['findings']:
                if finding['id'] == finding_id:
                    return finding.get('remediation', "No remediation information available")
                    
        return "Finding not found"
        
    def export_report(self, scan_id=None, format="json"):
        """Export vulnerability report in specified format"""
        results = self.get_scan_results(scan_id)
        
        if not results:
            logger.error("No scan results to export")
            return None
            
        try:
            report_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "reports")
            os.makedirs(report_dir, exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            report_file = os.path.join(report_dir, f"vulnerability_report_{timestamp}.{format}")
            
            if format == "json":
                with open(report_file, 'w') as f:
                    json.dump(results, f, indent=2)
            elif format == "txt":
                with open(report_file, 'w') as f:
                    f.write(f"PhantomUF Vulnerability Report\n")
                    f.write(f"Scan ID: {results['scan_id']}\n")
                    f.write(f"Scan Type: {results['scan_type']}\n")
                    f.write(f"Start Time: {results['start_time']}\n")
                    f.write(f"End Time: {results['end_time']}\n\n")
                    
                    f.write("Summary:\n")
                    for severity, count in results['summary'].items():
                        f.write(f"  {severity.capitalize()}: {count}\n")
                    f.write("\n")
                    
                    f.write("Findings:\n")
                    for i, finding in enumerate(results['findings'], 1):
                        f.write(f"{i}. [{finding['severity'].upper()}] {finding['title']}\n")
                        f.write(f"   Description: {finding['description']}\n")
                        f.write(f"   Affected: {finding['affected']}\n")
                        if 'remediation' in finding:
                            f.write(f"   Remediation: {finding['remediation']}\n")
                        f.write("\n")
            else:
                logger.error(f"Unsupported report format: {format}")
                return None
                
            logger.info(f"Exported vulnerability report to {report_file}")
            return report_file
            
        except Exception as e:
            logger.error(f"Failed to export vulnerability report: {e}")
            return None
            
    def _load_vulnerability_database(self):
        """Load vulnerability database"""
        # This would load from a local database file or API
        # For now, return a simple mock database
        return {
            'cve': {
                'CVE-2021-44228': {
                    'title': 'Log4j Remote Code Execution',
                    'description': 'Remote code execution vulnerability in Log4j',
                    'severity': 'high',
                    'affected': 'Log4j versions < 2.15.0',
                    'detection': r'log4j-core-.+\.jar',
                    'remediation': 'Update to Log4j 2.15.0 or later'
                }
            },
            'misconfig': {
                'WEAK_SSH_CONFIG': {
                    'title': 'Weak SSH Configuration',
                    'description': 'SSH server allows weak ciphers or authentication methods',
                    'severity': 'medium',
                    'detection': r'PasswordAuthentication\s+yes',
                    'remediation': 'Disable password authentication and use key-based authentication'
                },
                'EXPOSED_SENSITIVE_PORT': {
                    'title': 'Exposed Sensitive Port',
                    'description': 'Sensitive port is exposed to the public internet',
                    'severity': 'high',
                    'detection': None,  # Dynamic check
                    'remediation': 'Restrict access to sensitive ports using firewall rules'
                }
            }
        }
        
    def _scheduler(self):
        """Thread to schedule and run scans based on configuration"""
        logger.info("Vulnerability scan scheduler started")
        
        while self.running:
            try:
                current_time = datetime.now()
                
                for scan in self.scheduled_scans:
                    schedule = scan['schedule']
                    last_run = scan['last_run']
                    
                    # Check if scan should run based on schedule
                    should_run = False
                    
                    if not last_run:
                        should_run = True
                    elif schedule == 'daily' and (current_time - last_run).days >= 1:
                        should_run = True
                    elif schedule == 'weekly' and (current_time - last_run).days >= 7:
                        should_run = True
                    elif schedule == 'monthly' and (current_time - last_run).days >= 30:
                        should_run = True
                        
                    if should_run:
                        logger.info(f"Running scheduled {scan['type']} vulnerability scan")
                        self.run_scan(scan['type'])
                        scan['last_run'] = current_time
                        
                # Sleep for a bit before checking again
                threading.Event().wait(3600)  # Check every hour
                
            except Exception as e:
                logger.error(f"Error in vulnerability scan scheduler: {e}")
                threading.Event().wait(3600)
                
    def _scan_system_vulnerabilities(self, scan_results):
        """Scan for system-level vulnerabilities"""
        logger.info("Scanning for system vulnerabilities")
        
        try:
            # Check kernel version
            kernel_version = self._get_kernel_version()
            
            # Check installed packages
            installed_packages = self._get_installed_packages()
            
            # Check for vulnerable software versions
            for package, version in installed_packages.items():
                # This would check against a database of known vulnerabilities
                # For demonstration, add a mock finding
                if package == "openssh-server" and version.startswith("1."):
                    finding = {
                        'id': f"SYS-{len(scan_results['findings'])+1}",
                        'title': 'Outdated OpenSSH Server',
                        'description': 'The installed OpenSSH server is outdated and contains known vulnerabilities',
                        'severity': 'high',
                        'affected': f'openssh-server {version}',
                        'remediation': 'Update OpenSSH server to the latest version'
                    }
                    
                    scan_results['findings'].append(finding)
                    scan_results['summary']['high'] += 1
                    
            # Check for weak file permissions
            weak_permissions = self._check_file_permissions()
            for file_path, issue in weak_permissions.items():
                finding = {
                    'id': f"SYS-{len(scan_results['findings'])+1}",
                    'title': 'Weak File Permissions',
                    'description': f'File has insecure permissions: {issue}',
                    'severity': 'medium',
                    'affected': file_path,
                    'remediation': 'Set appropriate permissions using chmod'
                }
                
                scan_results['findings'].append(finding)
                scan_results['summary']['medium'] += 1
                
        except Exception as e:
            logger.error(f"Error during system vulnerability scan: {e}")
            
    def _scan_network_vulnerabilities(self, scan_results):
        """Scan for network-level vulnerabilities"""
        logger.info("Scanning for network vulnerabilities")
        
        try:
            # Check open ports
            open_ports = self._get_open_ports()
            
            # Check for sensitive open ports
            sensitive_ports = {
                21: 'FTP',
                23: 'Telnet',
                139: 'NetBIOS',
                445: 'SMB',
                3306: 'MySQL',
                5432: 'PostgreSQL',
                6379: 'Redis',
                9200: 'Elasticsearch',
                27017: 'MongoDB'
            }
            
            for port in open_ports:
                if port in sensitive_ports:
                    finding = {
                        'id': f"NET-{len(scan_results['findings'])+1}",
                        'title': f'Exposed {sensitive_ports[port]} Service',
                        'description': f'{sensitive_ports[port]} service is exposed on port {port}',
                        'severity': 'medium',
                        'affected': f'Port {port}',
                        'remediation': f'Restrict access to {sensitive_ports[port]} service using firewall rules'
                    }
                    
                    scan_results['findings'].append(finding)
                    scan_results['summary']['medium'] += 1
                    
            # Check for unnecessary services
            unnecessary_services = self._check_unnecessary_services()
            for service in unnecessary_services:
                finding = {
                    'id': f"NET-{len(scan_results['findings'])+1}",
                    'title': f'Unnecessary Service Running',
                    'description': f'Service {service} is running but may not be needed',
                    'severity': 'low',
                    'affected': service,
                    'remediation': f'Disable {service} if not required'
                }
                
                scan_results['findings'].append(finding)
                scan_results['summary']['low'] += 1
                
        except Exception as e:
            logger.error(f"Error during network vulnerability scan: {e}")
            
    def _scan_web_vulnerabilities(self, scan_results):
        """Scan for web application vulnerabilities"""
        logger.info("Scanning for web vulnerabilities")
        
        try:
            # Check if web servers are running
            web_servers = self._check_web_servers()
            
            for server_info in web_servers:
                server_type = server_info['type']
                server_version = server_info['version']
                server_port = server_info['port']
                
                # Check for outdated web servers
                if (server_type == 'Apache' and server_version.startswith('2.2')) or \
                   (server_type == 'Nginx' and server_version < '1.18'):
                    finding = {
                        'id': f"WEB-{len(scan_results['findings'])+1}",
                        'title': f'Outdated {server_type} Web Server',
                        'description': f'Running outdated {server_type} version {server_version}',
                        'severity': 'medium',
                        'affected': f'{server_type} on port {server_port}',
                        'remediation': f'Update {server_type} to the latest stable version'
                    }
                    
                    scan_results['findings'].append(finding)
                    scan_results['summary']['medium'] += 1
                    
                # Check for HTTPS
                if not server_info.get('https', False):
                    finding = {
                        'id': f"WEB-{len(scan_results['findings'])+1}",
                        'title': 'HTTP Without HTTPS',
                        'description': f'Web server on port {server_port} does not use HTTPS',
                        'severity': 'medium',
                        'affected': f'{server_type} on port {server_port}',
                        'remediation': 'Configure HTTPS with a valid SSL certificate'
                    }
                    
                    scan_results['findings'].append(finding)
                    scan_results['summary']['medium'] += 1
                    
        except Exception as e:
            logger.error(f"Error during web vulnerability scan: {e}")
            
    def _scan_config_vulnerabilities(self, scan_results):
        """Scan for security misconfigurations"""
        logger.info("Scanning for security misconfigurations")
        
        try:
            # Check common config files
            config_files = [
                '/etc/ssh/sshd_config',
                '/etc/passwd',
                '/etc/shadow'
            ]
            
            for config_file in config_files:
                if not os.path.exists(config_file):
                    continue
                    
                try:
                    with open(config_file, 'r') as f:
                        content = f.read()
                        
                    # Check against known misconfiguration patterns
                    for vuln_id, vuln_data in self.vulnerability_database['misconfig'].items():
                        if vuln_data['detection'] and re.search(vuln_data['detection'], content):
                            finding = {
                                'id': f"CONFIG-{len(scan_results['findings'])+1}",
                                'title': vuln_data['title'],
                                'description': vuln_data['description'],
                                'severity': vuln_data['severity'],
                                'affected': config_file,
                                'remediation': vuln_data['remediation']
                            }
                            
                            scan_results['findings'].append(finding)
                            scan_results['summary'][vuln_data['severity']] += 1
                            
                except Exception as e:
                    logger.warning(f"Could not read config file {config_file}: {e}")
                    
        except Exception as e:
            logger.error(f"Error during configuration vulnerability scan: {e}")
            
    def _get_kernel_version(self):
        """Get the kernel version"""
        try:
            output = subprocess.check_output(["uname", "-r"], universal_newlines=True).strip()
            return output
        except Exception:
            return "Unknown"
            
    def _get_installed_packages(self):
        """Get installed packages and versions"""
        packages = {}
        
        try:
            # Try to use dpkg (Debian/Ubuntu)
            output = subprocess.check_output(
                ["dpkg-query", "-W", "-f=${Package} ${Version}\n"],
                universal_newlines=True
            )
            
            for line in output.strip().split('\n'):
                if ' ' in line:
                    name, version = line.split(' ', 1)
                    packages[name] = version
                    
        except subprocess.SubprocessError:
            try:
                # Try to use rpm (Red Hat/CentOS)
                output = subprocess.check_output(
                    ["rpm", "-qa", "--qf", "%{NAME} %{VERSION}\n"],
                    universal_newlines=True
                )
                
                for line in output.strip().split('\n'):
                    if ' ' in line:
                        name, version = line.split(' ', 1)
                        packages[name] = version
                        
            except subprocess.SubprocessError:
                logger.warning("Could not determine installed packages")
                
        return packages
        
    def _check_file_permissions(self):
        """Check for files with weak permissions"""
        weak_permissions = {}
        
        sensitive_files = [
            '/etc/shadow',
            '/etc/passwd',
            '/etc/ssh/ssh_host_*key'
        ]
        
        for file_pattern in sensitive_files:
            try:
                # Use glob to expand patterns
                import glob
                for file_path in glob.glob(file_pattern):
                    try:
                        mode = os.stat(file_path).st_mode
                        
                        # Check if world-readable
                        if mode & 0o004:
                            weak_permissions[file_path] = "World-readable"
                            
                        # Check if world-writable
                        if mode & 0o002:
                            weak_permissions[file_path] = "World-writable"
                            
                        # Check if group-writable for sensitive files
                        if file_path.endswith('key') and (mode & 0o020):
                            weak_permissions[file_path] = "Group-writable key file"
                            
                    except Exception as e:
                        logger.warning(f"Could not check permissions for {file_path}: {e}")
                        
            except Exception as e:
                logger.warning(f"Error checking file pattern {file_pattern}: {e}")
                
        return weak_permissions
        
    def _get_open_ports(self):
        """Get list of open ports"""
        open_ports = []
        
        try:
            output = subprocess.check_output(["netstat", "-tuln"], universal_newlines=True)
            
            for line in output.split('\n'):
                if 'LISTEN' in line:
                    parts = line.split()
                    if len(parts) >= 4:
                        addr_port = parts[3]
                        if ':' in addr_port:
                            port = addr_port.split(':')[-1]
                            try:
                                open_ports.append(int(port))
                            except ValueError:
                                pass
                                
        except Exception as e:
            logger.warning(f"Could not determine open ports: {e}")
            
        return sorted(list(set(open_ports)))
        
    def _check_unnecessary_services(self):
        """Check for unnecessary services"""
        unnecessary_services = []
        
        potential_unnecessary = [
            'telnet', 'rsh', 'rlogin', 'rexec', 'vsftpd', 'xinetd'
        ]
        
        try:
            output = subprocess.check_output(["systemctl", "list-units", "--type=service", "--state=running"], universal_newlines=True)
            
            for service in potential_unnecessary:
                if f"{service}.service" in output:
                    unnecessary_services.append(f"{service}.service")
                    
        except Exception as e:
            logger.warning(f"Could not check for unnecessary services: {e}")
            
        return unnecessary_services
        
    def _check_web_servers(self):
        """Check for running web servers"""
        web_servers = []
        
        # Check common web server ports
        web_ports = [80, 443, 8080, 8443]
        
        for port in web_ports:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(1)
                result = s.connect_ex(('127.0.0.1', port))
                s.close()
                
                if result == 0:
                    # Port is open, try to identify server
                    server_info = {
                        'port': port,
                        'type': 'Unknown',
                        'version': 'Unknown',
                        'https': port in [443, 8443]
                    }
                    
                    # Advanced version would do a real banner grab
                    # Mock discovery for now
                    if port == 80:
                        server_info['type'] = 'Apache'
                        server_info['version'] = '2.4.41'
                    elif port == 8080:
                        server_info['type'] = 'Nginx'
                        server_info['version'] = '1.18.0'
                        
                    web_servers.append(server_info)
                    
            except Exception as e:
                logger.debug(f"Error checking port {port}: {e}")
                
        return web_servers
